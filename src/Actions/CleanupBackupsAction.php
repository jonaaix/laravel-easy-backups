<?php

declare(strict_types=1);

namespace Aaix\LaravelEasyBackups\Actions;

use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

final class CleanupBackupsAction
{
   public function execute(string $disk, string $path, int $maxBackups): void
   {
      if ($maxBackups <= 0) {
         return;
      }

      if ($disk === 'local') {
         $this->cleanupLocalBackups($path, $maxBackups);
      } else {
         $this->cleanupRemoteBackups($disk, $path, $maxBackups);
      }
   }

   private function isBackupFile(string $filename): bool
   {
      // Support all formats generated by our CompressionFormatEnum + raw SQL
      return Str::endsWith($filename, ['.zip', '.tar', '.gz', '.zst', '.sql']);
   }

   private function cleanupRemoteBackups(string $disk, string $path, int $maxBackups): void
   {
      $remoteDisk = Storage::disk($disk);

      $allBackups = collect($remoteDisk->files($path))
         ->filter(fn($file) => $this->isBackupFile(basename($file)))
         ->mapWithKeys(fn($file) => [$file => $remoteDisk->lastModified($file)])
         ->sort(); // Sort oldest to newest

      if ($allBackups->count() > $maxBackups) {
         $filesToDelete = $allBackups->keys()->slice(0, $allBackups->count() - $maxBackups);
         $remoteDisk->delete($filesToDelete->toArray());
      }
   }

   private function cleanupLocalBackups(string $path, int $maxBackups): void
   {
      if (!File::isDirectory($path)) {
         return;
      }

      $allBackups = collect(File::files($path))
         ->filter(fn(\SplFileInfo $file) => $this->isBackupFile($file->getFilename()))
         ->mapWithKeys(fn(\SplFileInfo $file) => [$file->getPathname() => $file->getMTime()])
         ->sort(); // Sort oldest to newest

      if ($allBackups->count() > $maxBackups) {
         $filesToDelete = $allBackups->keys()->slice(0, $allBackups->count() - $maxBackups);
         File::delete($filesToDelete->toArray());
      }
   }
}
